type AudioAsset {
  createdAt: String!
  goalId: Int!
  id: String!
  language: String!
  manifest: AudioManifest!
  mimeType: String!
  storyId: Int
  userId: String!
  voice: String!
}

type AudioManifest {
  segmentCount: Int!
  segments: [AudioSegmentInfo!]!
  totalDuration: Float
}

type AudioSegmentInfo {
  duration: Float
  idx: Int!
  url: String!
}

input BuildClaimCardsInput {
  claims: [String!]
  perSourceLimit: Int
  sources: [ResearchSource!]
  text: String
  topK: Int
  useLlmJudge: Boolean
}

type BuildClaimCardsResult {
  cards: [ClaimCard!]!
}

input CheckNoteClaimsInput {
  evidenceTopK: Int
  maxClaims: Int
  maxSourcesToResolve: Int
  noteId: Int!
  sources: [ResearchSource!]
  useJudge: Boolean
}

type CheckNoteClaimsResult {
  cards: [ClaimCard!]!
  message: String
  noteId: Int!
  success: Boolean!
}

type ClaimCard {
  claim: String!
  confidence: Float!
  createdAt: String!
  evidence: [EvidenceItem!]!
  id: ID!
  notes: String
  provenance: ClaimProvenance!
  queries: [String!]!
  scope: ClaimScope
  updatedAt: String!
  verdict: ClaimVerdict!
}

type ClaimProvenance {
  generatedBy: String!
  model: String
  sourceTools: [String!]!
}

type ClaimScope {
  comparator: String
  intervention: String
  outcome: String
  population: String
  setting: String
  timeframe: String
}

enum ClaimVerdict {
  CONTRADICTED
  INSUFFICIENT
  MIXED
  SUPPORTED
  UNVERIFIED
}

input CreateGoalInput {
  description: String
  familyMemberId: Int!
  priority: String
  targetDate: String
  title: String!
}

input CreateNoteInput {
  content: String!
  createdBy: String
  entityId: Int!
  entityType: String!
  linkedResearchIds: [Int!]
  noteType: String
  slug: String
  tags: [String!]
  title: String
  userId: String!
}

type DeleteGoalResult {
  message: String
  success: Boolean!
}

type DeleteNoteResult {
  message: String
  success: Boolean!
}

type DeleteQuestionsResult {
  deletedCount: Int!
  message: String
  success: Boolean!
}

type DeleteResearchResult {
  deletedCount: Int!
  message: String
  success: Boolean!
}

type EvidenceItem {
  excerpt: String
  locator: EvidenceLocator
  paper: PaperCandidate!
  polarity: EvidencePolarity!
  rationale: String
  score: Float
}

type EvidenceLocator {
  page: Int
  section: String
  url: String
}

enum EvidencePolarity {
  CONTRADICTS
  IRRELEVANT
  MIXED
  SUPPORTS
}

type GenerateAudioResult {
  audioUrl: String
  jobId: String!
  message: String
  success: Boolean!
}

type GenerateLongFormTextResult {
  audioUrl: String
  jobId: String
  manifestUrl: String
  message: String
  segmentUrls: [String!]
  storyId: Int
  success: Boolean!
  text: String
}

type GenerateQuestionsResult {
  jobId: String
  message: String
  questions: [TherapeuticQuestion!]!
  success: Boolean!
}

type GenerateResearchResult {
  count: Int
  jobId: String
  message: String
  success: Boolean!
}

type GenerationJob {
  createdAt: String!
  error: JobError
  goalId: Int!
  id: String!
  progress: Float!
  result: JobResult
  status: JobStatus!
  storyId: Int
  type: JobType!
  updatedAt: String!
  userId: String!
}

type Goal {
  createdAt: String!
  description: String
  familyMemberId: Int!
  id: Int!
  notes: [Note!]!
  priority: String!
  questions: [TherapeuticQuestion!]!
  research: [Research!]!
  status: String!
  stories: [GoalStory!]!
  targetDate: String
  therapeuticText: String
  therapeuticTextGeneratedAt: String
  therapeuticTextLanguage: String
  title: String!
  updatedAt: String!
  userId: String!
}

type GoalStory {
  audioAssets: [AudioAsset!]!
  createdAt: String!
  goalId: Int!
  id: Int!
  language: String!
  minutes: Int!
  segments: [TextSegment!]!
  text: String!
  updatedAt: String!
}

type JobError {
  code: String
  details: String
  message: String!
}

type JobResult {
  assetId: String
  audioUrl: String
  count: Int
  manifestUrl: String
  questions: [TherapeuticQuestion!]
  segmentUrls: [String!]
  text: String
}

enum JobStatus {
  FAILED
  RUNNING
  SUCCEEDED
}

enum JobType {
  AUDIO
  LONGFORM
  QUESTIONS
  RESEARCH
}

type Mutation {
  buildClaimCards(input: BuildClaimCardsInput!): BuildClaimCardsResult!
  checkNoteClaims(input: CheckNoteClaimsInput!): CheckNoteClaimsResult!
  createGoal(input: CreateGoalInput!): Goal!
  createNote(input: CreateNoteInput!): Note!
  deleteClaimCard(id: ID!): Boolean!
  deleteGoal(id: Int!): DeleteGoalResult!
  deleteNote(id: Int!): DeleteNoteResult!
  deleteResearch(goalId: Int!): DeleteResearchResult!
  deleteTherapeuticQuestions(goalId: Int!): DeleteQuestionsResult!
  generateAudio(goalId: Int!, language: String, storyId: Int, text: String, voice: String): GenerateAudioResult!
  generateLongFormText(goalId: Int!, language: String, minutes: Int): GenerateLongFormTextResult!
  generateResearch(goalId: Int!): GenerateResearchResult!
  generateTherapeuticQuestions(goalId: Int!): GenerateQuestionsResult!
  refreshClaimCard(id: ID!): ClaimCard!
  updateGoal(id: Int!, input: UpdateGoalInput!): Goal!
  updateNote(id: Int!, input: UpdateNoteInput!): Note!
}

type Note {
  claimCards: [ClaimCard!]
  content: String!
  createdAt: String!
  createdBy: String
  entityId: Int!
  entityType: String!
  goal: Goal
  id: Int!
  linkedResearch: [Research!]
  noteType: String
  slug: String
  tags: [String!]
  title: String
  updatedAt: String!
  userId: String!
}

type PaperCandidate {
  abstract: String
  authors: [String!]
  doi: String
  journal: String
  oaStatus: String
  oaUrl: String
  source: String!
  title: String!
  url: String
  year: Int
}

type Query {
  claimCard(id: ID!): ClaimCard
  claimCardsForNote(noteId: Int!): [ClaimCard!]!
  generationJob(id: String!): GenerationJob
  generationJobs(goalId: Int, status: String): [GenerationJob!]!
  goal(id: Int!, userId: String!): Goal
  goals(familyMemberId: Int, status: String, userId: String!): [Goal!]!
  note(id: Int, slug: String, userId: String!): Note
  notes(entityId: Int!, entityType: String!, userId: String!): [Note!]!
  research(goalId: Int!, userId: String!): [Research!]!
  therapeuticQuestions(goalId: Int!): [TherapeuticQuestion!]!
}

type Research {
  abstract: String
  authors: [String!]!
  createdAt: String!
  doi: String
  evidenceLevel: String
  extractedBy: String!
  extractionConfidence: Float!
  goal: Goal
  goalId: Int!
  id: Int!
  journal: String
  keyFindings: [String!]!
  relevanceScore: Float!
  therapeuticGoalType: String!
  therapeuticTechniques: [String!]!
  title: String!
  updatedAt: String!
  url: String
  year: Int
}

enum ResearchSource {
  ARXIV
  CROSSREF
  DATACITE
  EUROPEPMC
  OPENALEX
  PUBMED
  SEMANTIC_SCHOLAR
}

type Subscription {
  audioJobStatus(jobId: String!): GenerationJob!
  researchJobStatus(jobId: String!): GenerationJob!
}

type TextSegment {
  createdAt: String!
  goalId: Int!
  id: Int!
  idx: Int!
  storyId: Int
  text: String!
}

type TherapeuticQuestion {
  createdAt: String!
  generatedAt: String!
  goalId: Int!
  id: Int!
  question: String!
  rationale: String!
  researchId: Int
  researchTitle: String
  updatedAt: String!
}

input UpdateGoalInput {
  description: String
  priority: String
  status: String
  targetDate: String
  title: String
}

input UpdateNoteInput {
  content: String
  createdBy: String
  linkedResearchIds: [Int!]
  noteType: String
  tags: [String!]
  title: String
}