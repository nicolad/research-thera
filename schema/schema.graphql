type Query {
  goals(familyMemberId: Int, status: String): [Goal!]!
  goal(id: Int, slug: String): Goal
  research(goalId: Int!): [Research!]!
  therapeuticQuestions(goalId: Int!): [TherapeuticQuestion!]!
  notes(entityId: Int!, entityType: String!): [Note!]!
  allNotes: [Note!]!
  note(id: Int, slug: String): Note
  mySharedNotes: [Note!]!

  stories(goalId: Int!): [Story!]!
  story(id: Int!): Story
  generationJob(id: String!): GenerationJob
  generationJobs(goalId: Int, status: String): [GenerationJob!]!

  # Family Members
  familyMembers: [FamilyMember!]!
  familyMember(id: Int!): FamilyMember
  mySharedFamilyMembers: [FamilyMember!]!

  # Claim Cards
  claimCard(id: ID!): ClaimCard
  claimCardsForNote(noteId: Int!): [ClaimCard!]!

  # R2 Audio
  audioFromR2(key: String!): AudioFromR2Result

  # Journal
  journalEntries(
    familyMemberId: Int
    goalId: Int
    mood: String
    fromDate: String
    toDate: String
  ): [JournalEntry!]!
  journalEntry(id: Int!): JournalEntry
}

type Mutation {
  # Goals
  createGoal(input: CreateGoalInput!): Goal!
  updateGoal(id: Int!, input: UpdateGoalInput!): Goal!
  deleteGoal(id: Int!): DeleteGoalResult!

  createSubGoal(goalId: Int!, input: CreateSubGoalInput!): Goal!

  # Async generation workflows
  generateResearch(goalId: Int!): GenerateResearchResult!
  deleteResearch(goalId: Int!): DeleteResearchResult!
  generateTherapeuticQuestions(goalId: Int!): GenerateQuestionsResult!
  deleteTherapeuticQuestions(goalId: Int!): DeleteQuestionsResult!
  generateLongFormText(
    goalId: Int!
    language: String
    minutes: Int
  ): GenerateLongFormTextResult!
  generateAudio(
    goalId: Int!
    storyId: Int
    text: String
    language: String
    voice: String
  ): GenerateAudioResult!

  # Notes
  createNote(input: CreateNoteInput!): Note!
  updateNote(id: Int!, input: UpdateNoteInput!): Note!
  deleteNote(id: Int!): DeleteNoteResult!
  setNoteVisibility(noteId: Int!, visibility: NoteVisibility!): Note!
  shareNote(noteId: Int!, email: String!, role: NoteShareRole): NoteShare!
  unshareNote(noteId: Int!, email: String!): Boolean!

  # Stories
  createStory(input: CreateStoryInput!): Story!
  updateStory(id: Int!, input: UpdateStoryInput!): Story!
  deleteStory(id: Int!): DeleteStoryResult!

  # Claim Cards
  buildClaimCards(input: BuildClaimCardsInput!): BuildClaimCardsResult!
  checkNoteClaims(input: CheckNoteClaimsInput!): CheckNoteClaimsResult!
  refreshClaimCard(id: ID!): ClaimCard!
  deleteClaimCard(id: ID!): Boolean!

  # OpenAI TTS
  generateOpenAIAudio(
    input: GenerateOpenAIAudioInput!
  ): GenerateOpenAIAudioResult!

  # Journal
  createJournalEntry(input: CreateJournalEntryInput!): JournalEntry!
  updateJournalEntry(id: Int!, input: UpdateJournalEntryInput!): JournalEntry!
  deleteJournalEntry(id: Int!): DeleteJournalEntryResult!

  # Family Members
  createFamilyMember(input: CreateFamilyMemberInput!): FamilyMember!
  updateFamilyMember(id: Int!, input: UpdateFamilyMemberInput!): FamilyMember!
  deleteFamilyMember(id: Int!): DeleteFamilyMemberResult!
  shareFamilyMember(familyMemberId: Int!, email: String!, role: FamilyMemberShareRole): FamilyMemberShare!
  unshareFamilyMember(familyMemberId: Int!, email: String!): Boolean!
}

type Subscription {
  researchJobStatus(jobId: String!): GenerationJob!
  audioJobStatus(jobId: String!): GenerationJob!
}

# ============================================
# Core Types
# ============================================

enum NoteVisibility {
  PRIVATE
  PUBLIC
}

enum NoteShareRole {
  READER
  EDITOR
}

type NoteShare {
  noteId: Int!
  email: String!
  role: NoteShareRole!
  createdAt: String!
  createdBy: String!
}

type NoteAccess {
  canRead: Boolean!
  canEdit: Boolean!
  reason: String
}

type Goal {
  id: Int!
  familyMemberId: Int!
  familyMember: FamilyMember
  createdBy: String!
  slug: String
  title: String!
  description: String
  status: String!
  parentGoalId: Int
  parentGoal: Goal
  subGoals: [Goal!]!
  createdAt: String!
  updatedAt: String!
  research: [Research!]!
  questions: [TherapeuticQuestion!]!
  stories: [GoalStory!]!
  userStories: [Story!]!
  notes: [Note!]!
  therapeuticText: String
  therapeuticTextLanguage: String
  therapeuticTextGeneratedAt: String
}

type Story {
  id: Int!
  goalId: Int!
  createdBy: String!
  content: String!
  audioKey: String
  audioUrl: String
  audioGeneratedAt: String
  createdAt: String!
  updatedAt: String!
  goal: Goal
}

type GoalStory {
  id: Int!
  goalId: Int!
  language: String!
  minutes: Int!
  text: String!
  createdAt: String!
  updatedAt: String!
  segments: [TextSegment!]!
  audioAssets: [AudioAsset!]!
}

type TextSegment {
  id: Int!
  goalId: Int!
  storyId: Int
  idx: Int!
  text: String!
  createdAt: String!
}

type Research {
  id: Int!
  goalId: Int!
  therapeuticGoalType: String!
  title: String!
  authors: [String!]!
  year: Int
  journal: String
  doi: String
  url: String
  abstract: String
  keyFindings: [String!]!
  therapeuticTechniques: [String!]!
  evidenceLevel: String
  relevanceScore: Float!
  extractedBy: String!
  extractionConfidence: Float!
  createdAt: String!
  updatedAt: String!
  goal: Goal
}

type TherapeuticQuestion {
  id: Int!
  goalId: Int!
  question: String!
  researchId: Int
  researchTitle: String
  rationale: String!
  generatedAt: String!
  createdAt: String!
  updatedAt: String!
}

type Note {
  id: Int!
  entityId: Int!
  entityType: String!
  createdBy: String!
  noteType: String
  slug: String
  title: String
  content: String!
  tags: [String!]
  visibility: NoteVisibility!
  linkedResearch: [Research!]
  claimCards: [ClaimCard!]
  goal: Goal
  shares: [NoteShare!]!
  viewerAccess: NoteAccess!
  createdAt: String!
  updatedAt: String!
}

# ============================================
# Audio & Job Types
# ============================================

type GenerationJob {
  id: String!
  userId: String!
  type: JobType!
  goalId: Int!
  storyId: Int
  status: JobStatus!
  progress: Float!
  result: JobResult
  error: JobError
  createdAt: String!
  updatedAt: String!
}

enum JobType {
  AUDIO
  RESEARCH
  QUESTIONS
  LONGFORM
}

enum JobStatus {
  RUNNING
  SUCCEEDED
  FAILED
}

type JobResult {
  audioUrl: String
  manifestUrl: String
  segmentUrls: [String!]
  assetId: String
  count: Int
  text: String
  questions: [TherapeuticQuestion!]
}

type JobError {
  message: String!
  code: String
  details: String
}

type AudioAsset {
  id: String!
  createdBy: String!
  goalId: Int!
  storyId: Int
  language: String!
  voice: String!
  mimeType: String!
  manifest: AudioManifest!
  createdAt: String!
}

type AudioManifest {
  segmentCount: Int!
  totalDuration: Float
  segments: [AudioSegmentInfo!]!
}

type AudioSegmentInfo {
  idx: Int!
  duration: Float
  url: String!
}

# ============================================
# Input Types
# ============================================

input CreateGoalInput {
  familyMemberId: Int!
  title: String!
  description: String
}

input CreateSubGoalInput {
  title: String!
  description: String
}

input UpdateGoalInput {
  title: String
  description: String
  status: String
}

input CreateNoteInput {
  entityId: Int!
  entityType: String!
  noteType: String
  slug: String
  title: String
  content: String!
  tags: [String!]
  linkedResearchIds: [Int!]
}

input UpdateNoteInput {
  noteType: String
  title: String
  content: String
  createdBy: String
  tags: [String!]
  linkedResearchIds: [Int!]
}

input CreateStoryInput {
  goalId: Int!
  content: String!
}

input UpdateStoryInput {
  content: String
}

# ============================================
# Result Types
# ============================================

type GenerateResearchResult {
  success: Boolean!
  message: String
  jobId: String
  count: Int
}

type GenerateLongFormTextResult {
  success: Boolean!
  message: String
  jobId: String
  storyId: Int
  text: String
  audioUrl: String
  manifestUrl: String
  segmentUrls: [String!]
}

type GenerateAudioResult {
  success: Boolean!
  message: String
  jobId: String!
  audioUrl: String
}

type GenerateQuestionsResult {
  success: Boolean!
  message: String
  jobId: String
  questions: [TherapeuticQuestion!]!
}

type DeleteGoalResult {
  success: Boolean!
  message: String
}

type DeleteQuestionsResult {
  success: Boolean!
  message: String
  deletedCount: Int!
}

type DeleteResearchResult {
  success: Boolean!
  message: String
  deletedCount: Int!
}

type DeleteNoteResult {
  success: Boolean!
  message: String
}

type DeleteStoryResult {
  success: Boolean!
  message: String
}

# ============================================
# Claim Cards
# ============================================

type ClaimScope {
  population: String
  intervention: String
  comparator: String
  outcome: String
  timeframe: String
  setting: String
}

type EvidenceLocator {
  section: String
  page: Int
  url: String
}

type EvidenceItem {
  paper: PaperCandidate!
  polarity: EvidencePolarity!
  excerpt: String
  rationale: String
  score: Float
  locator: EvidenceLocator
}

type ClaimCard {
  id: ID!
  claim: String!
  scope: ClaimScope
  verdict: ClaimVerdict!
  confidence: Float!
  evidence: [EvidenceItem!]!
  queries: [String!]!
  createdAt: String!
  updatedAt: String!
  provenance: ClaimProvenance!
  notes: String
}

type ClaimProvenance {
  generatedBy: String!
  model: String
  sourceTools: [String!]!
}

type PaperCandidate {
  title: String!
  doi: String
  url: String
  year: Int
  source: String!
  authors: [String!]
  abstract: String
  journal: String
  oaUrl: String
  oaStatus: String
}

enum ClaimVerdict {
  UNVERIFIED
  SUPPORTED
  CONTRADICTED
  MIXED
  INSUFFICIENT
}

enum EvidencePolarity {
  SUPPORTS
  CONTRADICTS
  MIXED
  IRRELEVANT
}

input BuildClaimCardsInput {
  text: String
  claims: [String!]
  perSourceLimit: Int
  topK: Int
  useLlmJudge: Boolean
  sources: [ResearchSource!]
}

input CheckNoteClaimsInput {
  noteId: Int!
  maxClaims: Int
  maxSourcesToResolve: Int
  evidenceTopK: Int
  useJudge: Boolean
  sources: [ResearchSource!]
}

enum ResearchSource {
  CROSSREF
  PUBMED
  SEMANTIC_SCHOLAR
  OPENALEX
  ARXIV
  EUROPEPMC
  DATACITE
}

type BuildClaimCardsResult {
  cards: [ClaimCard!]!
}

type CheckNoteClaimsResult {
  success: Boolean!
  message: String
  cards: [ClaimCard!]!
  noteId: Int!
}

# ============================================
# OpenAI TTS Types
# ============================================

enum OpenAITTSVoice {
  ALLOY
  ASH
  BALLAD
  CORAL
  ECHO
  FABLE
  ONYX
  NOVA
  SAGE
  SHIMMER
  VERSE
  MARIN
  CEDAR
}

enum OpenAITTSModel {
  TTS_1
  TTS_1_HD
  GPT_4O_MINI_TTS
}

enum OpenAIAudioFormat {
  MP3
  OPUS
  AAC
  FLAC
  WAV
  PCM
}

enum OpenAIStreamFormat {
  SSE
  AUDIO
}

input GenerateOpenAIAudioInput {
  text: String!
  storyId: Int
  voice: OpenAITTSVoice
  model: OpenAITTSModel
  speed: Float
  responseFormat: OpenAIAudioFormat
  uploadToCloud: Boolean
  streamFormat: OpenAIStreamFormat
  instructions: String
}

type GenerateOpenAIAudioResult {
  success: Boolean!
  message: String
  jobId: String
  audioBuffer: String
  audioUrl: String
  key: String
  sizeBytes: Int
  duration: Float
}

type AudioFromR2Result {
  success: Boolean!
  message: String
  audioUrl: String
  key: String
  metadata: AudioMetadata
}

# ============================================
# Family Members
# ============================================

type FamilyMember {
  id: Int!
  userId: String!
  firstName: String!
  name: String
  ageYears: Int
  relationship: String
  dateOfBirth: String
  bio: String
  email: String
  phone: String
  location: String
  occupation: String
  createdAt: String!
  updatedAt: String!
  goals: [Goal!]!
  shares: [FamilyMemberShare!]!
}

input CreateFamilyMemberInput {
  firstName: String!
  name: String
  ageYears: Int
  relationship: String
  dateOfBirth: String
  bio: String
  email: String
  phone: String
  location: String
  occupation: String
}

input UpdateFamilyMemberInput {
  firstName: String
  name: String
  ageYears: Int
  relationship: String
  dateOfBirth: String
  bio: String
  email: String
  phone: String
  location: String
  occupation: String
}

type DeleteFamilyMemberResult {
  success: Boolean!
  message: String
}

enum FamilyMemberShareRole {
  VIEWER
  EDITOR
}

type FamilyMemberShare {
  familyMemberId: Int!
  email: String!
  role: FamilyMemberShareRole!
  createdAt: String!
  createdBy: String!
}

type AudioMetadata {
  voice: String
  model: String
  textLength: String
  chunks: String
  generatedBy: String
  instructions: String
}

# ============================================
# Journal
# ============================================

type JournalEntry {
  id: Int!
  userId: String!
  familyMemberId: Int
  familyMember: FamilyMember
  title: String
  content: String!
  mood: String
  moodScore: Int
  tags: [String!]
  goalId: Int
  goal: Goal
  isPrivate: Boolean!
  entryDate: String!
  createdAt: String!
  updatedAt: String!
}

input CreateJournalEntryInput {
  familyMemberId: Int
  title: String
  content: String!
  mood: String
  moodScore: Int
  tags: [String!]
  goalId: Int
  isPrivate: Boolean
  entryDate: String!
}

input UpdateJournalEntryInput {
  familyMemberId: Int
  title: String
  content: String
  mood: String
  moodScore: Int
  tags: [String!]
  goalId: Int
  isPrivate: Boolean
  entryDate: String
}

type DeleteJournalEntryResult {
  success: Boolean!
  message: String
}
